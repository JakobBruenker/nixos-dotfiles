snippet case
	case ${1:_expr} of
	  ${2:_pat} -> ${3:_result}

snippet lcase
	\case ${1:_pat} -> ${2:_result}
	`repeat(" ", 6 + strlen(getline(line('.'))))`${3:_pat_1} -> ${4:_result_1}

snippet do
	do ${1:_action}
	`repeat(" ", 3 + strlen(getline(line('.'))))`${2:_action_1}

snippet wh
	where ${1:fn} = ${2:_body}

snippet let
	let ${1:var} = ${2:_expr}
	in ${3:_body}

snippet new
	newtype ${1:TypeName} = $1 { un$1 :: ${2:Type} }
	  deriving ($4)

snippet mod
	module ${1:ModuleName} where
	$2

snippet if
	if | ${1:_cond} -> ${2:_result}
	`repeat(" ", 3 + strlen(getline(line('.'))))`| ${4:otherwise} -> ${3:_result_1}

snippet im
	import qualified ${1:Module} as ${2:M}

snippet iq
	import qualified ${1:Module} as ${2:M}

snippet cl
	class ${1:ClassName} where
	  ${2:fn} :: ${3:Type}

snippet in
	instance ${1:Class} ${2:Type} where

snippet rec
	data ${1:TypeName} = $1
		{ ${2:field} :: ${3:Type}
		} deriving (${4})

snippet ff
	foreign import ccall safe "${1:cfunction}" ${2:fname}
	  :: ${3:function}

snippet lan
	{-# LANGUAGE ${1} #-}

snippet \
	(\\${1} -> ${2:_hole})

snippet bar
	-------------------------------------------------------------------------------
	-- ${1}
	-------------------------------------------------------------------------------

snippet line
	-------------------------------------------------------------------------------

snippet mm
	import Control.Monad
	import Control.Applicative
	import Control.Monad.State
	import Control.Monad.Reader
	import Control.Monad.Except

snippet usual
	import Data.Maybe
	import Data.Functor
	import Data.Foldable
	import Data.Traversable
	import Control.Monad
	import Control.Applicative

snippet fold
	import Data.Foldable
	import Data.Traversable

snippet bs
	import qualified Data.ByteString as S
	import qualified Data.ByteString.Char8 as S8

snippet containers
	import qualified Data.HashMap.Lazy as HashMap
	import qualified Data.HashSet      as HashSet
	import qualified Data.IntMap       as IntMap
	import qualified Data.IntSet       as IntSet
	import qualified Data.IxSet        as IxSet
	import qualified Data.Map          as Map
	import qualified Data.Sequence     as Seq
	import qualified Data.Set          as Set

snippet str
	{-# LANGUAGE OverloadedStrings #-}

snippet gadt
	{-# LANGUAGE GADTs #-}

snippet rank
	{-# LANGUAGE RankNTypes #-}

snippet scope
	{-# LANGUAGE ScopedTypeVariables #-}

snippet ffi
	{-# LANGUAGE ForeignFunctionInterface #-}

snippet flex
	{-# LANGUAGE FlexibleInstances #-}
	{-# LANGUAGE FlexibleContexts #-}
	{-# LANGUAGE TypeSynonymInstances #-}

snippet syn
	{-# LANGUAGE TypeSynonymInstances #-}

snippet mparam
	{-# LANGUAGE MultiParamTypeClasses #-}

snippet bang
	{-# LANGUAGE BangPatterns #-}

snippet gnew
	{-# LANGUAGE GeneralizedNewtypeDeriving #-}

snippet mono
	{-# LANGUAGE NoMonomorphismRestriction #-}

snippet stand
	{-# LANGUAGE StandaloneDeriving #-}

snippet temp
	{-# LANGUAGE TemplateHaskell #-}

snippet derive
	{-# LANGUAGE DeriveDataTypeable #-}
	{-# LANGUAGE DeriveGeneric #-}
	{-# LANGUAGE DeriveFunctor #-}
	{-# LANGUAGE DeriveTraversable #-}
	{-# LANGUAGE DeriveFoldable #-}

snippet type
	{-# LANGUAGE GADTs #-}
	{-# LANGUAGE TypeFamilies #-}
	{-# LANGUAGE TypeOperators #-}
	{-# LANGUAGE DataKinds #-}
	{-# LANGUAGE PolyKinds #-}
	{-# LANGUAGE KindSignatures #-}
	{-# LANGUAGE FlexibleInstances #-}
	{-# LANGUAGE FlexibleContexts #-}
	{-# LANGUAGE UndecidableInstances #-}

	import GHC.TypeLits
	import Data.Proxy
	import Data.Type.Equality
	import Data.Reflection
	import Data.Constraint
	import GHC.Exts (Constraint)
	import GHC.Prim (Any, AnyK)

snippet crazy
	{-# LANGUAGE GADTs #-}
	{-# LANGUAGE DataKinds #-}
	{-# LANGUAGE RankNTypes #-}
	{-# LANGUAGE TypeFamilies #-}
	{-# LANGUAGE TypeOperators #-}
	{-# LANGUAGE KindSignatures #-}
	{-# LANGUAGE FlexibleInstances #-}
	{-# LANGUAGE FlexibleContexts #-}
	{-# LANGUAGE MultiParamTypeClasses #-}
	{-# LANGUAGE UndecidableInstances #-}
	{-# LANGUAGE ExistentialQuantification #-}

snippet main
	main :: IO ()
	main = ${1:_action}

snippet opt
	{-# OPTIONS_GHC ${1} #-}

snippet wall
	{-# OPTIONS_GHC -Wall #-}

snippet nowarn
	{-# OPTIONS_GHC -fno-warn-name-shadowing  #-}
	{-# OPTIONS_GHC -fno-warn-type-defaults   #-}
	{-# OPTIONS_GHC -fno-warn-unused-do-bind  #-}

snippet box
	--------------------------------------------------------------------
	-- |
	-- Module    :  ${1:ModuleName}
	-- Copyright :  (c) ${2:AuthorName} `strftime("%Y")`
	-- License   :  ${3:MIT}
	-- Maintainer:  ${4:Email}
	-- Stability :  experimental
	-- Portability: non-portable
	--
	--------------------------------------------------------------------

snippet dd
	deriving (Eq, Ord, Show, Typeable, Data, Generic)

snippet inl
	{-# INLINE ${1} #-}

snippet up
	{-# UNPACK #-}

snippet hl
	_hole

snippet un
	undefined

snippet er
	error "${1}"

snippet header
	module ${1:ModuleName} where

	import ClassyPrelude

	default(Integer, Double, Text)
